---
layout: post
title: "链表基础操作"
date: 2018-05-08
excerpt: "2018-05-08 链表反转、查找倒数第k个节点."
tags: [C++, 链表]
comments: true
---

## **链表反转**
{% highlight python %}
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
//非递归方法：需要三个指针完成，要注意链表断裂的考虑
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead==nullptr || pHead->next==nullptr)
            return pHead;
        ListNode* pNext=pHead->next;
        ListNode* pReverse=pHead;
        ListNode* pPre=pHead;
        while(pNext->next != nullptr)
        {
            pReverse=pNext;
            pNext=pNext->next;
            pReverse->next=pPre;
            pPre=pReverse;
        }
        pNext->next=pPre;
        pHead->next=nullptr;
        return pNext;
    }
};
{% endhighlight %}

## **查找倒数第k个节点**
{% highlight python %}
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
//注意边界问题
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        ListNode* pFast=pListHead;
        ListNode* pSlow=pListHead;
        if(pListHead==nullptr || k<0)
            return nullptr;
        for(int i=0;i<k;i++)
        {
            if(pFast==nullptr)
                return nullptr;
            pFast=pFast->next;
        }
        while(pFast!=nullptr)
        {
            pFast=pFast->next;
            pSlow=pSlow->next;
        }
        return pSlow;
    }
};
{% endhighlight %}



1111111111111111111
